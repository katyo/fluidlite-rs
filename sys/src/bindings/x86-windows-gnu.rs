/* automatically generated by rust-bindgen 0.60.1 */

pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FLUID_HINT_BOUNDED_BELOW: u32 = 1;
pub const FLUID_HINT_BOUNDED_ABOVE: u32 = 2;
pub const FLUID_HINT_TOGGLED: u32 = 4;
pub const FLUID_HINT_SAMPLE_RATE: u32 = 8;
pub const FLUID_HINT_LOGARITHMIC: u32 = 16;
pub const FLUID_HINT_INTEGER: u32 = 32;
pub const FLUID_HINT_FILENAME: u32 = 1;
pub const FLUID_HINT_OPTIONLIST: u32 = 2;
pub const FLUID_REVERB_DEFAULT_ROOMSIZE: f64 = 0.2;
pub const FLUID_REVERB_DEFAULT_DAMP: f64 = 0.0;
pub const FLUID_REVERB_DEFAULT_WIDTH: f64 = 0.5;
pub const FLUID_REVERB_DEFAULT_LEVEL: f64 = 0.9;
pub const FLUID_CHORUS_DEFAULT_N: u32 = 3;
pub const FLUID_CHORUS_DEFAULT_LEVEL: f64 = 2.0;
pub const FLUID_CHORUS_DEFAULT_SPEED: f64 = 0.3;
pub const FLUID_CHORUS_DEFAULT_DEPTH: f64 = 8.0;
pub const FLUID_SAMPLETYPE_MONO: u32 = 1;
pub const FLUID_SAMPLETYPE_RIGHT: u32 = 2;
pub const FLUID_SAMPLETYPE_LEFT: u32 = 4;
pub const FLUID_SAMPLETYPE_LINKED: u32 = 8;
pub const FLUID_SAMPLETYPE_OGG_VORBIS: u32 = 16;
pub const FLUID_SAMPLETYPE_OGG_VORBIS_UNPACKED: u32 = 32;
pub const FLUID_SAMPLETYPE_ROM: u32 = 32768;
pub const FLUID_NUM_MOD: u32 = 64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_hashtable_t {
    _unused: [u8; 0],
}
pub type fluid_settings_t = _fluid_hashtable_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_synth_t {
    _unused: [u8; 0],
}
pub type fluid_synth_t = _fluid_synth_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_voice_t {
    _unused: [u8; 0],
}
pub type fluid_voice_t = _fluid_voice_t;
pub type fluid_sfloader_t = _fluid_sfloader_t;
pub type fluid_sfont_t = _fluid_sfont_t;
pub type fluid_preset_t = _fluid_preset_t;
pub type fluid_sample_t = _fluid_sample_t;
pub type fluid_mod_t = _fluid_mod_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_audio_driver_t {
    _unused: [u8; 0],
}
pub type fluid_audio_driver_t = _fluid_audio_driver_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_player_t {
    _unused: [u8; 0],
}
pub type fluid_player_t = _fluid_player_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_midi_event_t {
    _unused: [u8; 0],
}
pub type fluid_midi_event_t = _fluid_midi_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_midi_driver_t {
    _unused: [u8; 0],
}
pub type fluid_midi_driver_t = _fluid_midi_driver_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_midi_router_t {
    _unused: [u8; 0],
}
pub type fluid_midi_router_t = _fluid_midi_router_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_midi_router_rule_t {
    _unused: [u8; 0],
}
pub type fluid_midi_router_rule_t = _fluid_midi_router_rule_t;
pub type fluid_cmd_handler_t = _fluid_hashtable_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_shell_t {
    _unused: [u8; 0],
}
pub type fluid_shell_t = _fluid_shell_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_server_t {
    _unused: [u8; 0],
}
pub type fluid_server_t = _fluid_server_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_event_t {
    _unused: [u8; 0],
}
pub type fluid_event_t = _fluid_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_sequencer_t {
    _unused: [u8; 0],
}
pub type fluid_sequencer_t = _fluid_sequencer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_ramsfont_t {
    _unused: [u8; 0],
}
pub type fluid_ramsfont_t = _fluid_ramsfont_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_rampreset_t {
    _unused: [u8; 0],
}
pub type fluid_rampreset_t = _fluid_rampreset_t;
#[doc = " File callback structure to enable custom soundfont loading (e.g. from memory)."]
pub type fluid_fileapi_t = _fluid_fileapi_t;
pub type fluid_istream_t = ::std::os::raw::c_int;
pub type fluid_ostream_t = ::std::os::raw::c_int;
pub const fluid_types_enum_FLUID_NO_TYPE: fluid_types_enum = -1;
pub const fluid_types_enum_FLUID_NUM_TYPE: fluid_types_enum = 0;
pub const fluid_types_enum_FLUID_INT_TYPE: fluid_types_enum = 1;
pub const fluid_types_enum_FLUID_STR_TYPE: fluid_types_enum = 2;
pub const fluid_types_enum_FLUID_SET_TYPE: fluid_types_enum = 3;
pub type fluid_types_enum = ::std::os::raw::c_int;
extern "C" {
    pub fn new_fluid_settings() -> *mut fluid_settings_t;
}
extern "C" {
    pub fn delete_fluid_settings(settings: *mut fluid_settings_t);
}
extern "C" {
    pub fn fluid_settings_get_type(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_settings_get_hints(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the setting is changeable in real-time."]
    pub fn fluid_settings_is_realtime(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns 1 if the value has been set, 0 otherwise"]
    pub fn fluid_settings_setstr(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the value of a string setting. If the value does not exists,"]
    #[doc = "'str' is set to NULL. Otherwise, 'str' will point to the"]
    #[doc = "value. The application does not own the returned value. Instead,"]
    #[doc = "the application should make a copy of the value if it needs it"]
    #[doc = "later."]
    #[doc = ""]
    #[doc = "\\returns 1 if the value exists, 0 otherwise"]
    pub fn fluid_settings_getstr(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default value of a string setting."]
    pub fn fluid_settings_getstr_default(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the value of a numeric setting."]
    #[doc = ""]
    #[doc = "\\returns 1 if the value exists and is equal to 'value', 0"]
    #[doc = "otherwise"]
    pub fn fluid_settings_str_equal(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns 1 if the value has been set, 0 otherwise"]
    pub fn fluid_settings_setnum(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns 1 if the value exists, 0 otherwise"]
    pub fn fluid_settings_getnum(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        val: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default value of a string setting."]
    pub fn fluid_settings_getnum_default(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the range of values of a numeric settings."]
    pub fn fluid_settings_getnum_range(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        min: *mut f64,
        max: *mut f64,
    );
}
extern "C" {
    #[doc = " returns 1 if the value has been set, 0 otherwise"]
    pub fn fluid_settings_setint(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns 1 if the value exists, 0 otherwise"]
    pub fn fluid_settings_getint(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the default value of a string setting."]
    pub fn fluid_settings_getint_default(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the range of values of a numeric settings."]
    pub fn fluid_settings_getint_range(
        settings: *mut fluid_settings_t,
        name: *const ::std::os::raw::c_char,
        min: *mut ::std::os::raw::c_int,
        max: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates a new synthesizer object."]
    #[doc = ""]
    #[doc = "  Creates a new synthesizer object. As soon as the synthesizer is"]
    #[doc = "  created, it will start playing."]
    #[doc = ""]
    #[doc = " \\param settings a pointer to a settings structure"]
    #[doc = " \\return a newly allocated synthesizer or NULL in case of error"]
    pub fn new_fluid_synth(settings: *mut fluid_settings_t) -> *mut fluid_synth_t;
}
extern "C" {
    pub fn fluid_synth_set_sample_rate(synth: *mut fluid_synth_t, sample_rate: f32);
}
extern "C" {
    #[doc = " Deletes the synthesizer previously created with new_fluid_synth."]
    #[doc = ""]
    #[doc = " \\param synth the synthesizer object"]
    #[doc = " \\return 0 if no error occured, -1 otherwise"]
    pub fn delete_fluid_synth(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a reference to the settings of the synthesizer."]
    #[doc = ""]
    #[doc = " \\param synth the synthesizer object"]
    #[doc = " \\return pointer to the settings"]
    pub fn fluid_synth_get_settings(synth: *mut fluid_synth_t) -> *mut fluid_settings_t;
}
extern "C" {
    #[doc = " Send a noteon message. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_noteon(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        vel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a noteoff message. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_noteoff(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a control change message. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_cc(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        ctrl: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a control value. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_get_cc(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        ctrl: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a pitch bend message. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_pitch_bend(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the pitch bend value. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_get_pitch_bend(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        ppitch_bend: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the pitch wheel sensitivity. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_pitch_wheel_sens(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the pitch wheel sensitivity. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_get_pitch_wheel_sens(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        pval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a program change message. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_program_change(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        program: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_channel_pressure(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_key_pressure(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_sysex(
        synth: *mut fluid_synth_t,
        data: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        response: *mut ::std::os::raw::c_char,
        response_len: *mut ::std::os::raw::c_int,
        handled: *mut ::std::os::raw::c_int,
        dryrun: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select a bank. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_bank_select(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        bank: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select a sfont. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_sfont_select(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        sfont_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select a preset for a channel. The preset is specified by the"]
    #[doc = "SoundFont ID, the bank number, and the preset number. This"]
    #[doc = "allows any preset to be selected and circumvents preset masking"]
    #[doc = "due to previously loaded SoundFonts on the SoundFont stack."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer"]
    #[doc = "\\param chan The channel on which to set the preset"]
    #[doc = "\\param sfont_id The ID of the SoundFont"]
    #[doc = "\\param bank_num The bank number"]
    #[doc = "\\param preset_num The preset number"]
    #[doc = "\\return 0 if no errors occured, -1 otherwise"]
    pub fn fluid_synth_program_select(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        sfont_id: ::std::os::raw::c_uint,
        bank_num: ::std::os::raw::c_uint,
        preset_num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the program, bank, and SoundFont number of the preset on"]
    #[doc = "a given channel. Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_get_program(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        sfont_id: *mut ::std::os::raw::c_uint,
        bank_num: *mut ::std::os::raw::c_uint,
        preset_num: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a bank select and a program change to every channel to"]
    #[doc = "  reinitialize the preset of the channel. This function is useful"]
    #[doc = "  mainly after a SoundFont has been loaded, unloaded or"]
    #[doc = "  reloaded. . Returns 0 if no error occurred, -1 otherwise."]
    pub fn fluid_synth_program_reset(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a reset. A reset turns all the notes off and resets the"]
    #[doc = "controller values."]
    pub fn fluid_synth_system_reset(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and start voices using a preset. The id passed as"]
    #[doc = " argument will be used as the voice group id."]
    pub fn fluid_synth_start(
        synth: *mut fluid_synth_t,
        id: ::std::os::raw::c_uint,
        preset: *mut fluid_preset_t,
        audio_chan: ::std::os::raw::c_int,
        midi_chan: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        vel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the voices in the voice group defined by id."]
    pub fn fluid_synth_stop(
        synth: *mut fluid_synth_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set an optional function callback each time a preset has finished loading."]
    #[doc = "This can be useful when calling fluid_synth_sfload asynchronously."]
    #[doc = "The function must be formatted like this:"]
    #[doc = "void my_callback_function(int bank, int num, char* name)"]
    #[doc = ""]
    #[doc = "\\param callback Pointer to the function"]
    pub fn fluid_synth_set_preset_callback(callback: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Loads a SoundFont file and creates a new SoundFont. The newly"]
    #[doc = "loaded SoundFont will be put on top of the SoundFont"]
    #[doc = "stack. Presets are searched starting from the SoundFont on the"]
    #[doc = "top of the stack, working the way down the stack until a preset"]
    #[doc = "is found."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param filename The file name"]
    #[doc = "\\param reset_presets If non-zero, the presets on the channels will be reset"]
    #[doc = "\\returns The ID of the loaded SoundFont, or -1 in case of error"]
    pub fn fluid_synth_sfload(
        synth: *mut fluid_synth_t,
        filename: *const ::std::os::raw::c_char,
        reset_presets: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reload a SoundFont. The reloaded SoundFont retains its ID and"]
    #[doc = "index on the stack."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param id The id of the SoundFont"]
    #[doc = "\\returns The ID of the loaded SoundFont, or -1 in case of error"]
    pub fn fluid_synth_sfreload(
        synth: *mut fluid_synth_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes a SoundFont from the stack and deallocates it."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param id The id of the SoundFont"]
    #[doc = "\\param reset_presets If TRUE then presets will be reset for all channels"]
    #[doc = "\\returns 0 if no error, -1 otherwise"]
    pub fn fluid_synth_sfunload(
        synth: *mut fluid_synth_t,
        id: ::std::os::raw::c_uint,
        reset_presets: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a SoundFont. The SoundFont will be put on top of"]
    #[doc = "the SoundFont stack."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param sfont The SoundFont"]
    #[doc = "\\returns The ID of the loaded SoundFont, or -1 in case of error"]
    pub fn fluid_synth_add_sfont(
        synth: *mut fluid_synth_t,
        sfont: *mut fluid_sfont_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a SoundFont that was previously added using"]
    #[doc = "  fluid_synth_add_sfont(). The synthesizer does not delete the"]
    #[doc = "  SoundFont; this is responsability of the caller."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param sfont The SoundFont"]
    pub fn fluid_synth_remove_sfont(synth: *mut fluid_synth_t, sfont: *mut fluid_sfont_t);
}
extern "C" {
    #[doc = " Count the number of loaded SoundFonts."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\returns The number of loaded SoundFonts"]
    pub fn fluid_synth_sfcount(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a SoundFont. The SoundFont is specified by its index on the"]
    #[doc = "stack. The top of the stack has index zero."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param num The number of the SoundFont (0 <= num < sfcount)"]
    #[doc = "\\returns A pointer to the SoundFont"]
    pub fn fluid_synth_get_sfont(
        synth: *mut fluid_synth_t,
        num: ::std::os::raw::c_uint,
    ) -> *mut fluid_sfont_t;
}
extern "C" {
    #[doc = " Get a SoundFont. The SoundFont is specified by its ID."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param id The id of the sfont"]
    #[doc = "\\returns A pointer to the SoundFont"]
    pub fn fluid_synth_get_sfont_by_id(
        synth: *mut fluid_synth_t,
        id: ::std::os::raw::c_uint,
    ) -> *mut fluid_sfont_t;
}
extern "C" {
    #[doc = " Get the preset of a channel"]
    pub fn fluid_synth_get_channel_preset(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
    ) -> *mut fluid_preset_t;
}
extern "C" {
    #[doc = " Offset the bank numbers in a SoundFont. Returns -1 if an error"]
    #[doc = " occured (out of memory or negative offset)"]
    pub fn fluid_synth_set_bank_offset(
        synth: *mut fluid_synth_t,
        sfont_id: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the offset of the bank numbers in a SoundFont."]
    pub fn fluid_synth_get_bank_offset(
        synth: *mut fluid_synth_t,
        sfont_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the parameters for the built-in reverb unit"]
    pub fn fluid_synth_set_reverb(
        synth: *mut fluid_synth_t,
        roomsize: f64,
        damping: f64,
        width: f64,
        level: f64,
    );
}
extern "C" {
    #[doc = " Turn on (1) / off (0) the built-in reverb unit"]
    pub fn fluid_synth_set_reverb_on(synth: *mut fluid_synth_t, on: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Query the current state of the reverb."]
    pub fn fluid_synth_get_reverb_roomsize(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_reverb_damp(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_reverb_level(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_reverb_width(synth: *mut fluid_synth_t) -> f64;
}
pub const fluid_chorus_mod_FLUID_CHORUS_MOD_SINE: fluid_chorus_mod = 0;
pub const fluid_chorus_mod_FLUID_CHORUS_MOD_TRIANGLE: fluid_chorus_mod = 1;
pub type fluid_chorus_mod = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Set up the chorus. It should be turned on with fluid_synth_set_chorus_on."]
    #[doc = " If faulty parameters are given, all new settings are discarded."]
    #[doc = " Keep in mind, that the needed CPU time is proportional to 'nr'."]
    pub fn fluid_synth_set_chorus(
        synth: *mut fluid_synth_t,
        nr: ::std::os::raw::c_int,
        level: f64,
        speed: f64,
        depth_ms: f64,
        type_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Turn on (1) / off (0) the built-in chorus unit"]
    pub fn fluid_synth_set_chorus_on(synth: *mut fluid_synth_t, on: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Query the current state of the chorus."]
    pub fn fluid_synth_get_chorus_nr(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_get_chorus_level(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_chorus_speed_Hz(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_chorus_depth_ms(synth: *mut fluid_synth_t) -> f64;
}
extern "C" {
    pub fn fluid_synth_get_chorus_type(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of MIDI channels that the synthesizer uses"]
    #[doc = "internally"]
    pub fn fluid_synth_count_midi_channels(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of audio channels that the synthesizer uses"]
    #[doc = "internally"]
    pub fn fluid_synth_count_audio_channels(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of audio groups that the synthesizer uses"]
    #[doc = "internally. This is usually identical to audio_channels."]
    pub fn fluid_synth_count_audio_groups(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of effects channels that the synthesizer uses"]
    #[doc = "internally"]
    pub fn fluid_synth_count_effects_channels(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the master gain"]
    pub fn fluid_synth_set_gain(synth: *mut fluid_synth_t, gain: f32);
}
extern "C" {
    #[doc = " Get the master gain"]
    pub fn fluid_synth_get_gain(synth: *mut fluid_synth_t) -> f32;
}
extern "C" {
    #[doc = " Set the polyphony limit (FluidSynth >= 1.0.6)"]
    pub fn fluid_synth_set_polyphony(
        synth: *mut fluid_synth_t,
        polyphony: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the polyphony limit (FluidSynth >= 1.0.6)"]
    pub fn fluid_synth_get_polyphony(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the internal buffer size. The internal buffer size if not the"]
    #[doc = "same thing as the buffer size specified in the"]
    #[doc = "settings. Internally, the synth *always* uses a specific buffer"]
    #[doc = "size independent of the buffer size used by the audio driver. The"]
    #[doc = "internal buffer size is normally 64 samples. The reason why it"]
    #[doc = "uses an internal buffer size is to allow audio drivers to call the"]
    #[doc = "synthesizer with a variable buffer length. The internal buffer"]
    #[doc = "size is useful for client who want to optimize their buffer sizes."]
    pub fn fluid_synth_get_internal_bufsize(synth: *mut fluid_synth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the interpolation method for one channel or all channels (chan = -1)"]
    pub fn fluid_synth_set_interp_method(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        interp_method: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const fluid_interp_FLUID_INTERP_NONE: fluid_interp = 0;
pub const fluid_interp_FLUID_INTERP_LINEAR: fluid_interp = 1;
pub const fluid_interp_FLUID_INTERP_DEFAULT: fluid_interp = 4;
pub const fluid_interp_FLUID_INTERP_4THORDER: fluid_interp = 4;
pub const fluid_interp_FLUID_INTERP_7THORDER: fluid_interp = 7;
pub const fluid_interp_FLUID_INTERP_HIGHEST: fluid_interp = 7;
pub type fluid_interp = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Change the value of a generator. This function allows to control"]
    #[doc = "all synthesis parameters in real-time. The changes are additive,"]
    #[doc = "i.e. they add up to the existing parameter value. This function is"]
    #[doc = "similar to sending an NRPN message to the synthesizer. The"]
    #[doc = "function accepts a float as the value of the parameter. The"]
    #[doc = "parameter numbers and ranges are described in the SoundFont 2.01"]
    #[doc = "specification, paragraph 8.1.3, page 48. See also 'fluid_gen_type'."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object."]
    #[doc = "\\param chan The MIDI channel number."]
    #[doc = "\\param param The parameter number."]
    #[doc = "\\param value The parameter value."]
    #[doc = "\\returns Your favorite dish."]
    pub fn fluid_synth_set_gen(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        param: ::std::os::raw::c_int,
        value: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retreive the value of a generator. This function returns the value"]
    #[doc = "set by a previous call 'fluid_synth_set_gen' or by an NRPN message."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object."]
    #[doc = "\\param chan The MIDI channel number."]
    #[doc = "\\param param The generator number."]
    #[doc = "\\returns The value of the generator."]
    pub fn fluid_synth_get_gen(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        param: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[doc = " Create a new key-based tuning with given name, number, and"]
    #[doc = "pitches. The array 'pitches' should have length 128 and contains"]
    #[doc = "the pitch in cents of every key in cents. However, if 'pitches' is"]
    #[doc = "NULL, a new tuning is created with the well-tempered scale."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param tuning_bank The tuning bank number [0-127]"]
    #[doc = "\\param tuning_prog The tuning program number [0-127]"]
    #[doc = "\\param name The name of the tuning"]
    #[doc = "\\param pitch The array of pitch values. The array length has to be 128."]
    pub fn fluid_synth_create_key_tuning(
        synth: *mut fluid_synth_t,
        tuning_bank: ::std::os::raw::c_int,
        tuning_prog: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        pitch: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new octave-based tuning with given name, number, and"]
    #[doc = "pitches.  The array 'pitches' should have length 12 and contains"]
    #[doc = "derivation in cents from the well-tempered scale. For example, if"]
    #[doc = "pitches[0] equals -33, then the C-keys will be tuned 33 cents"]
    #[doc = "below the well-tempered C."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param tuning_bank The tuning bank number [0-127]"]
    #[doc = "\\param tuning_prog The tuning program number [0-127]"]
    #[doc = "\\param name The name of the tuning"]
    #[doc = "\\param pitch The array of pitch derivations. The array length has to be 12."]
    pub fn fluid_synth_create_octave_tuning(
        synth: *mut fluid_synth_t,
        tuning_bank: ::std::os::raw::c_int,
        tuning_prog: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        pitch: *const f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_activate_octave_tuning(
        synth: *mut fluid_synth_t,
        bank: ::std::os::raw::c_int,
        prog: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        pitch: *const f64,
        apply: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request a note tuning changes. Both they 'keys' and 'pitches'"]
    #[doc = "arrays should be of length 'num_pitches'. If 'apply' is non-zero,"]
    #[doc = "the changes should be applied in real-time, i.e. sounding notes"]
    #[doc = "will have their pitch updated. 'APPLY' IS CURRENTLY IGNORED. The"]
    #[doc = "changes will be available for newly triggered notes only."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param tuning_bank The tuning bank number [0-127]"]
    #[doc = "\\param tuning_prog The tuning program number [0-127]"]
    #[doc = "\\param len The length of the keys and pitch arrays"]
    #[doc = "\\param keys The array of keys values."]
    #[doc = "\\param pitch The array of pitch values."]
    #[doc = "\\param apply Flag to indicate whether to changes should be applied in real-time."]
    pub fn fluid_synth_tune_notes(
        synth: *mut fluid_synth_t,
        tuning_bank: ::std::os::raw::c_int,
        tuning_prog: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        keys: *mut ::std::os::raw::c_int,
        pitch: *mut f64,
        apply: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select a tuning for a channel."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param chan The channel number [0-max channels]"]
    #[doc = "\\param tuning_bank The tuning bank number [0-127]"]
    #[doc = "\\param tuning_prog The tuning program number [0-127]"]
    pub fn fluid_synth_select_tuning(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        tuning_bank: ::std::os::raw::c_int,
        tuning_prog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_activate_tuning(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
        bank: ::std::os::raw::c_int,
        prog: ::std::os::raw::c_int,
        apply: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the tuning to the default well-tempered tuning on a channel."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param chan The channel number [0-max channels]"]
    pub fn fluid_synth_reset_tuning(
        synth: *mut fluid_synth_t,
        chan: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start the iteration throught the list of available tunings."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    pub fn fluid_synth_tuning_iteration_start(synth: *mut fluid_synth_t);
}
extern "C" {
    #[doc = " Get the next tuning in the iteration. This functions stores the"]
    #[doc = "bank and program number of the next tuning in the pointers given as"]
    #[doc = "arguments."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param bank Pointer to an int to store the bank number"]
    #[doc = "\\param prog Pointer to an int to store the program number"]
    #[doc = "\\returns 1 if there is a next tuning, 0 otherwise"]
    pub fn fluid_synth_tuning_iteration_next(
        synth: *mut fluid_synth_t,
        bank: *mut ::std::os::raw::c_int,
        prog: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the data of a tuning. This functions stores the name and"]
    #[doc = "pitch values of a tuning in the pointers given as arguments. Both"]
    #[doc = "name and pitch can be NULL is the data is not needed."]
    #[doc = ""]
    #[doc = "\\param synth The synthesizer object"]
    #[doc = "\\param bank The tuning bank number [0-127]"]
    #[doc = "\\param prog The tuning program number [0-127]"]
    #[doc = "\\param name Pointer to a buffer to store the name"]
    #[doc = "\\param len The length of the name buffer"]
    #[doc = "\\param pitch Pointer to buffer to store the pitch values"]
    pub fn fluid_synth_tuning_dump(
        synth: *mut fluid_synth_t,
        bank: ::std::os::raw::c_int,
        prog: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        pitch: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a textual representation of the last error"]
    pub fn fluid_synth_error(synth: *mut fluid_synth_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate a number of samples. This function expects two signed"]
    #[doc = "  16bits buffers (left and right channel) that will be filled with"]
    #[doc = "  samples."]
    #[doc = ""]
    #[doc = "  \\param synth The synthesizer"]
    #[doc = "  \\param len The number of samples to generate"]
    #[doc = "  \\param lout The sample buffer for the left channel"]
    #[doc = "  \\param loff The offset, in samples, in the left buffer where the writing pointer starts"]
    #[doc = "  \\param lincr The increment, in samples, of the writing pointer in the left buffer"]
    #[doc = "  \\param rout The sample buffer for the right channel"]
    #[doc = "  \\param roff The offset, in samples, in the right buffer where the writing pointer starts"]
    #[doc = "  \\param rincr The increment, in samples, of the writing pointer in the right buffer"]
    #[doc = "  \\returns 0 if no error occured, non-zero otherwise"]
    pub fn fluid_synth_write_s16(
        synth: *mut fluid_synth_t,
        len: ::std::os::raw::c_int,
        lout: *mut ::std::os::raw::c_void,
        loff: ::std::os::raw::c_int,
        lincr: ::std::os::raw::c_int,
        rout: *mut ::std::os::raw::c_void,
        roff: ::std::os::raw::c_int,
        rincr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a number of samples. This function expects two floating"]
    #[doc = "  point buffers (left and right channel) that will be filled with"]
    #[doc = "  samples."]
    #[doc = ""]
    #[doc = "  \\param synth The synthesizer"]
    #[doc = "  \\param len The number of samples to generate"]
    #[doc = "  \\param lout The sample buffer for the left channel"]
    #[doc = "  \\param loff The offset, in samples, in the left buffer where the writing pointer starts"]
    #[doc = "  \\param lincr The increment, in samples, of the writing pointer in the left buffer"]
    #[doc = "  \\param rout The sample buffer for the right channel"]
    #[doc = "  \\param roff The offset, in samples, in the right buffer where the writing pointer starts"]
    #[doc = "  \\param rincr The increment, in samples, of the writing pointer in the right buffer"]
    #[doc = "  \\returns 0 if no error occured, non-zero otherwise"]
    pub fn fluid_synth_write_float(
        synth: *mut fluid_synth_t,
        len: ::std::os::raw::c_int,
        lout: *mut ::std::os::raw::c_void,
        loff: ::std::os::raw::c_int,
        lincr: ::std::os::raw::c_int,
        rout: *mut ::std::os::raw::c_void,
        roff: ::std::os::raw::c_int,
        rincr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_synth_nwrite_float(
        synth: *mut fluid_synth_t,
        len: ::std::os::raw::c_int,
        left: *mut *mut f32,
        right: *mut *mut f32,
        fx_left: *mut *mut f32,
        fx_right: *mut *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a number of samples. This function implements the"]
    #[doc = "  default interface defined in fluidsynth/audio.h. This function"]
    #[doc = "  ignores the input buffers and expects at least two output"]
    #[doc = "  buffer."]
    #[doc = ""]
    #[doc = "  \\param synth The synthesizer"]
    #[doc = "  \\param len The number of samples to generate"]
    #[doc = "  \\param nin The number of input buffers"]
    #[doc = "  \\param in The array of input buffers"]
    #[doc = "  \\param nout The number of output buffers"]
    #[doc = "  \\param out The array of output buffers"]
    #[doc = "  \\returns 0 if no error occured, non-zero otherwise"]
    pub fn fluid_synth_process(
        synth: *mut fluid_synth_t,
        len: ::std::os::raw::c_int,
        nin: ::std::os::raw::c_int,
        in_: *mut *mut f32,
        nout: ::std::os::raw::c_int,
        out: *mut *mut f32,
    ) -> ::std::os::raw::c_int;
}
pub type fluid_audio_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        synth: *mut fluid_synth_t,
        len: ::std::os::raw::c_int,
        out1: *mut ::std::os::raw::c_void,
        loff: ::std::os::raw::c_int,
        lincr: ::std::os::raw::c_int,
        out2: *mut ::std::os::raw::c_void,
        roff: ::std::os::raw::c_int,
        rincr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Add a SoundFont loader to the synthesizer. Note that SoundFont"]
    #[doc = "loader don't necessarily load SoundFonts. They can load any type"]
    #[doc = "of wavetable data but export a SoundFont interface."]
    pub fn fluid_synth_add_sfloader(synth: *mut fluid_synth_t, loader: *mut fluid_sfloader_t);
}
extern "C" {
    #[doc = " Allocate a synthesis voice. This function is called by a"]
    #[doc = "soundfont's preset in response to a noteon event."]
    #[doc = "The returned voice comes with default modulators installed (velocity-to-attenuation,"]
    #[doc = "velocity to filter, ...)"]
    #[doc = "Note: A single noteon event may create any number of voices, when the preset is layered."]
    #[doc = "Typically 1 (mono) or 2 (stereo)."]
    pub fn fluid_synth_alloc_voice(
        synth: *mut fluid_synth_t,
        sample: *mut fluid_sample_t,
        channum: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        vel: ::std::os::raw::c_int,
    ) -> *mut fluid_voice_t;
}
extern "C" {
    #[doc = " Start a synthesis voice. This function is called by a"]
    #[doc = "soundfont's preset in response to a noteon event after the voice"]
    #[doc = "has been allocated with fluid_synth_alloc_voice() and"]
    #[doc = "initialized."]
    #[doc = "Exclusive classes are processed here."]
    pub fn fluid_synth_start_voice(synth: *mut fluid_synth_t, voice: *mut fluid_voice_t);
}
extern "C" {
    #[doc = " Write a list of all voices matching ID into buf, but not more than bufsize voices."]
    #[doc = " If ID <0, return all voices."]
    pub fn fluid_synth_get_voicelist(
        synth: *mut fluid_synth_t,
        buf: *mut *mut fluid_voice_t,
        bufsize: ::std::os::raw::c_int,
        ID: ::std::os::raw::c_int,
    );
}
pub const FLUID_PRESET_SELECTED: _bindgen_ty_1 = 0;
pub const FLUID_PRESET_UNSELECTED: _bindgen_ty_1 = 1;
pub const FLUID_SAMPLE_DONE: _bindgen_ty_1 = 2;
#[doc = "   SoundFont plugins"]
#[doc = ""]
#[doc = "    It is possible to add new SoundFont loaders to the"]
#[doc = "    synthesizer. The API uses a couple of \"interfaces\" (structures"]
#[doc = "    with callback functions): fluid_sfloader_t, fluid_sfont_t, and"]
#[doc = "    fluid_preset_t."]
#[doc = ""]
#[doc = "    To add a new SoundFont loader to the synthesizer, call"]
#[doc = "    fluid_synth_add_sfloader() and pass a pointer to an"]
#[doc = "    fluid_sfloader_t structure. The important callback function in"]
#[doc = "    this structure is \"load\", which should try to load a file and"]
#[doc = "    returns a fluid_sfont_t structure, or NULL if it fails."]
#[doc = ""]
#[doc = "    The fluid_sfont_t structure contains a callback to obtain the"]
#[doc = "    name of the soundfont. It contains two functions to iterate"]
#[doc = "    though the contained presets, and one function to obtain a"]
#[doc = "    preset corresponding to a bank and preset number. This"]
#[doc = "    function should return an fluid_preset_t structure."]
#[doc = ""]
#[doc = "    The fluid_preset_t structure contains some functions to obtain"]
#[doc = "    information from the preset (name, bank, number). The most"]
#[doc = "    important callback is the noteon function. The noteon function"]
#[doc = "    should call fluid_synth_alloc_voice() for every sample that has"]
#[doc = "    to be played. fluid_synth_alloc_voice() expects a pointer to a"]
#[doc = "    fluid_sample_t structure and returns a pointer to the opaque"]
#[doc = "    fluid_voice_t structure. To set or increments the values of a"]
#[doc = "    generator, use fluid_voice_gen_{set,incr}. When you are"]
#[doc = "    finished initializing the voice call fluid_voice_start() to"]
#[doc = "    start playing the synthesis voice."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_sfloader_t {
    #[doc = " Private data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The free must free the memory allocated for the loader in"]
    #[doc = " addition to any private data. It should return 0 if no error"]
    #[doc = " occured, non-zero otherwise."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(loader: *mut fluid_sfloader_t) -> ::std::os::raw::c_int,
    >,
    #[doc = " Load a file. Returns NULL if an error occured."]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            loader: *mut fluid_sfloader_t,
            filename: *const ::std::os::raw::c_char,
        ) -> *mut fluid_sfont_t,
    >,
    #[doc = " Callback structure specifying file operations used during soundfont loading to allow custom loading, such as from memory"]
    pub fileapi: *mut fluid_fileapi_t,
}
#[test]
fn bindgen_test_layout__fluid_sfloader_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_sfloader_t>(),
        16usize,
        concat!("Size of: ", stringify!(_fluid_sfloader_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_sfloader_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_fluid_sfloader_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfloader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfloader_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfloader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfloader_t),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_load() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfloader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfloader_t),
                "::",
                stringify!(load)
            )
        );
    }
    test_field_load();
    fn test_field_fileapi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfloader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileapi) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfloader_t),
                "::",
                stringify!(fileapi)
            )
        );
    }
    test_field_fileapi();
}
#[doc = " File callback structure to enable custom soundfont loading (e.g. from memory)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_fileapi_t {
    #[doc = " Private data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The free must free the memory allocated for the loader in"]
    #[doc = " addition to any private data. It should return 0 if no error"]
    #[doc = " occured, non-zero otherwise."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(fileapi: *mut fluid_fileapi_t) -> ::std::os::raw::c_int,
    >,
    #[doc = " Opens the file or memory indicated by \\c filename in binary read mode."]
    #[doc = " \\c filename matches the one provided during the fluid_synth_sfload() call."]
    #[doc = ""]
    #[doc = " @return returns a file handle on success, NULL otherwise"]
    pub fopen: ::std::option::Option<
        unsafe extern "C" fn(
            fileapi: *mut fluid_fileapi_t,
            filename: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Reads \\c count bytes to the specified buffer \\c buf."]
    #[doc = ""]
    #[doc = " @return returns #FLUID_OK if exactly \\c count bytes were successfully read, else #FLUID_FAILED"]
    pub fread: ::std::option::Option<
        unsafe extern "C" fn(
            buf: *mut ::std::os::raw::c_void,
            count: ::std::os::raw::c_int,
            handle: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Same purpose and behaviour as fseek."]
    #[doc = ""]
    #[doc = " @param origin either \\c SEEK_SET, \\c SEEK_CUR or \\c SEEK_END"]
    #[doc = ""]
    #[doc = " @return returns #FLUID_OK if the seek was successfully performed while not seeking beyond a buffer or file, #FLUID_FAILED otherwise"]
    pub fseek: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut ::std::os::raw::c_void,
            offset: ::std::os::raw::c_long,
            origin: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Closes the handle and frees used ressources."]
    #[doc = ""]
    #[doc = " @return returns #FLUID_OK on success, #FLUID_FAILED on error"]
    pub fclose: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " @return returns current file offset or #FLUID_FAILED on error"]
    pub ftell: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout__fluid_fileapi_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_fileapi_t>(),
        28usize,
        concat!("Size of: ", stringify!(_fluid_fileapi_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_fileapi_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_fluid_fileapi_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_fopen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fopen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(fopen)
            )
        );
    }
    test_field_fopen();
    fn test_field_fread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fread) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(fread)
            )
        );
    }
    test_field_fread();
    fn test_field_fseek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fseek) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(fseek)
            )
        );
    }
    test_field_fseek();
    fn test_field_fclose() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fclose) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(fclose)
            )
        );
    }
    test_field_fclose();
    fn test_field_ftell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_fileapi_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ftell) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_fileapi_t),
                "::",
                stringify!(ftell)
            )
        );
    }
    test_field_ftell();
}
extern "C" {
    pub fn fluid_init_default_fileapi(fileapi: *mut fluid_fileapi_t);
}
extern "C" {
    pub fn fluid_set_default_fileapi(fileapi: *mut fluid_fileapi_t);
}
extern "C" {
    pub fn new_fluid_defsfloader() -> *mut fluid_sfloader_t;
}
extern "C" {
    pub fn delete_fluid_defsfloader(loader: *mut fluid_sfloader_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_sfont_t {
    pub data: *mut ::std::os::raw::c_void,
    pub id: ::std::os::raw::c_uint,
    #[doc = " The 'free' callback function should return 0 when it was able to"]
    #[doc = "free all resources. It should return a non-zero value if some of"]
    #[doc = "the samples could not be freed because they are still in use."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(sfont: *mut fluid_sfont_t) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return the name of the sfont"]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(sfont: *mut fluid_sfont_t) -> *mut ::std::os::raw::c_char,
    >,
    #[doc = " Return the preset with the specified bank and preset number. All"]
    #[doc = "  the fields, including the 'sfont' field, should * be filled"]
    #[doc = "  in. If the preset cannot be found, the function returns NULL."]
    pub get_preset: ::std::option::Option<
        unsafe extern "C" fn(
            sfont: *mut fluid_sfont_t,
            bank: ::std::os::raw::c_uint,
            prenum: ::std::os::raw::c_uint,
        ) -> *mut fluid_preset_t,
    >,
    pub iteration_start: ::std::option::Option<unsafe extern "C" fn(sfont: *mut fluid_sfont_t)>,
    pub iteration_next: ::std::option::Option<
        unsafe extern "C" fn(
            sfont: *mut fluid_sfont_t,
            preset: *mut fluid_preset_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__fluid_sfont_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_sfont_t>(),
        28usize,
        concat!("Size of: ", stringify!(_fluid_sfont_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_sfont_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_fluid_sfont_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_preset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_preset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(get_preset)
            )
        );
    }
    test_field_get_preset();
    fn test_field_iteration_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iteration_start) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(iteration_start)
            )
        );
    }
    test_field_iteration_start();
    fn test_field_iteration_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sfont_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iteration_next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sfont_t),
                "::",
                stringify!(iteration_next)
            )
        );
    }
    test_field_iteration_next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_preset_t {
    pub data: *mut ::std::os::raw::c_void,
    pub sfont: *mut fluid_sfont_t,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut fluid_preset_t) -> ::std::os::raw::c_int,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut fluid_preset_t) -> *mut ::std::os::raw::c_char,
    >,
    pub get_banknum: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut fluid_preset_t) -> ::std::os::raw::c_int,
    >,
    pub get_num: ::std::option::Option<
        unsafe extern "C" fn(preset: *mut fluid_preset_t) -> ::std::os::raw::c_int,
    >,
    #[doc = " handle a noteon event. Returns 0 if no error occured."]
    pub noteon: ::std::option::Option<
        unsafe extern "C" fn(
            preset: *mut fluid_preset_t,
            synth: *mut fluid_synth_t,
            chan: ::std::os::raw::c_int,
            key: ::std::os::raw::c_int,
            vel: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Implement this function if the preset needs to be notified about"]
    #[doc = "preset select and unselect events."]
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            preset: *mut fluid_preset_t,
            reason: ::std::os::raw::c_int,
            chan: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__fluid_preset_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_preset_t>(),
        32usize,
        concat!("Size of: ", stringify!(_fluid_preset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_preset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_fluid_preset_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_sfont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sfont) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(sfont)
            )
        );
    }
    test_field_sfont();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_banknum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_banknum) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(get_banknum)
            )
        );
    }
    test_field_get_banknum();
    fn test_field_get_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_num) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(get_num)
            )
        );
    }
    test_field_get_num();
    fn test_field_noteon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).noteon) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(noteon)
            )
        );
    }
    test_field_noteon();
    fn test_field_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_preset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_preset_t),
                "::",
                stringify!(notify)
            )
        );
    }
    test_field_notify();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_sample_t {
    pub name: [::std::os::raw::c_char; 21usize],
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
    pub loopstart: ::std::os::raw::c_uint,
    pub loopend: ::std::os::raw::c_uint,
    pub samplerate: ::std::os::raw::c_uint,
    pub origpitch: ::std::os::raw::c_int,
    pub pitchadj: ::std::os::raw::c_int,
    pub sampletype: ::std::os::raw::c_int,
    pub valid: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_short,
    #[doc = " The amplitude, that will lower the level of the sample's loop to"]
    #[doc = "the noise floor. Needed for note turnoff optimization, will be"]
    #[doc = "filled out automatically"]
    pub amplitude_that_reaches_noise_floor_is_valid: ::std::os::raw::c_int,
    pub amplitude_that_reaches_noise_floor: f64,
    #[doc = " Count the number of playing voices that use this sample."]
    pub refcount: ::std::os::raw::c_uint,
    #[doc = " Implement this function if the sample or SoundFont needs to be"]
    #[doc = "notified when the sample is no longer used."]
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            sample: *mut fluid_sample_t,
            reason: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pointer to SoundFont specific data"]
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__fluid_sample_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_sample_t>(),
        96usize,
        concat!("Size of: ", stringify!(_fluid_sample_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_sample_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_fluid_sample_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_loopstart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loopstart) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(loopstart)
            )
        );
    }
    test_field_loopstart();
    fn test_field_loopend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loopend) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(loopend)
            )
        );
    }
    test_field_loopend();
    fn test_field_samplerate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(samplerate)
            )
        );
    }
    test_field_samplerate();
    fn test_field_origpitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origpitch) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(origpitch)
            )
        );
    }
    test_field_origpitch();
    fn test_field_pitchadj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pitchadj) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(pitchadj)
            )
        );
    }
    test_field_pitchadj();
    fn test_field_sampletype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampletype) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(sampletype)
            )
        );
    }
    test_field_sampletype();
    fn test_field_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(valid)
            )
        );
    }
    test_field_valid();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_amplitude_that_reaches_noise_floor_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).amplitude_that_reaches_noise_floor_is_valid) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(amplitude_that_reaches_noise_floor_is_valid)
            )
        );
    }
    test_field_amplitude_that_reaches_noise_floor_is_valid();
    fn test_field_amplitude_that_reaches_noise_floor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).amplitude_that_reaches_noise_floor) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(amplitude_that_reaches_noise_floor)
            )
        );
    }
    test_field_amplitude_that_reaches_noise_floor();
    fn test_field_refcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(refcount)
            )
        );
    }
    test_field_refcount();
    fn test_field_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(notify)
            )
        );
    }
    test_field_notify();
    fn test_field_userdata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_sample_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_sample_t),
                "::",
                stringify!(userdata)
            )
        );
    }
    test_field_userdata();
}
extern "C" {
    #[doc = " Creates a fluid_sfont_t wrapping an fluid_ramsfont_t"]
    pub fn fluid_ramsfont_create_sfont() -> *mut fluid_sfont_t;
}
extern "C" {
    #[doc = " ramsfont specific API"]
    pub fn fluid_ramsfont_set_name(
        sfont: *mut fluid_ramsfont_t,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_ramsfont_add_izone(
        sfont: *mut fluid_ramsfont_t,
        bank: ::std::os::raw::c_uint,
        num: ::std::os::raw::c_uint,
        sample: *mut fluid_sample_t,
        lokey: ::std::os::raw::c_int,
        hikey: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_ramsfont_remove_izone(
        sfont: *mut fluid_ramsfont_t,
        bank: ::std::os::raw::c_uint,
        num: ::std::os::raw::c_uint,
        sample: *mut fluid_sample_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_ramsfont_izone_set_gen(
        sfont: *mut fluid_ramsfont_t,
        bank: ::std::os::raw::c_uint,
        num: ::std::os::raw::c_uint,
        sample: *mut fluid_sample_t,
        gen_type: ::std::os::raw::c_int,
        value: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_ramsfont_izone_set_loop(
        sfont: *mut fluid_ramsfont_t,
        bank: ::std::os::raw::c_uint,
        num: ::std::os::raw::c_uint,
        sample: *mut fluid_sample_t,
        on: ::std::os::raw::c_int,
        loopstart: f32,
        loopend: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sample_t specific API for ramsfont"]
    pub fn new_fluid_ramsample() -> *mut fluid_sample_t;
}
extern "C" {
    pub fn delete_fluid_ramsample(sample: *mut fluid_sample_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_sample_set_name(
        sample: *mut fluid_sample_t,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_sample_set_sound_data(
        sample: *mut fluid_sample_t,
        data: *mut ::std::os::raw::c_short,
        nbframes: ::std::os::raw::c_uint,
        copy_data: ::std::os::raw::c_short,
        rootkey: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< The synth can't function correctly any more"]
pub const fluid_log_level_FLUID_PANIC: fluid_log_level = 0;
#[doc = "< Serious error occurred"]
pub const fluid_log_level_FLUID_ERR: fluid_log_level = 1;
#[doc = "< Warning"]
pub const fluid_log_level_FLUID_WARN: fluid_log_level = 2;
#[doc = "< Verbose informational messages"]
pub const fluid_log_level_FLUID_INFO: fluid_log_level = 3;
#[doc = "< Debugging messages"]
pub const fluid_log_level_FLUID_DBG: fluid_log_level = 4;
pub const fluid_log_level_LAST_LOG_LEVEL: fluid_log_level = 5;
#[doc = " FluidSynth log levels."]
pub type fluid_log_level = ::std::os::raw::c_uint;
#[doc = " Log function handler callback type used by fluid_set_log_function()."]
#[doc = " @param level Log level (#fluid_log_level)"]
#[doc = " @param message Log message text"]
#[doc = " @param data User data pointer supplied to fluid_set_log_function()."]
pub type fluid_log_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_int,
        message: *mut ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn fluid_set_log_function(
        level: ::std::os::raw::c_int,
        fun: fluid_log_function_t,
        data: *mut ::std::os::raw::c_void,
    ) -> fluid_log_function_t;
}
extern "C" {
    pub fn fluid_default_log_function(
        level: ::std::os::raw::c_int,
        message: *mut ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn fluid_log(
        level: ::std::os::raw::c_int,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " fluid_is_soundfont returns 1 if the specified filename is a"]
    #[doc = " soundfont. It retuns 0 otherwise. The current implementation only"]
    #[doc = " checks for the \"RIFF\" header in the file. It is useful only to"]
    #[doc = " distinguish between SoundFonts and MIDI files."]
    pub fn fluid_is_soundfont(filename: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " fluid_is_midifile returns 1 if the specified filename is a MIDI"]
    #[doc = " file. It retuns 0 otherwise. The current implementation only checks"]
    #[doc = " for the \"MThd\" header in the file."]
    pub fn fluid_is_midifile(filename: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the handle to the instance of the application on the Windows"]
    #[doc = "platform. The handle is needed to open DirectSound."]
    pub fn fluid_get_hinstance() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fluid_set_hinstance(hinstance: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_mod_t {
    pub dest: ::std::os::raw::c_uchar,
    pub src1: ::std::os::raw::c_uchar,
    pub flags1: ::std::os::raw::c_uchar,
    pub src2: ::std::os::raw::c_uchar,
    pub flags2: ::std::os::raw::c_uchar,
    pub amount: f64,
    pub next: *mut fluid_mod_t,
}
#[test]
fn bindgen_test_layout__fluid_mod_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_mod_t>(),
        24usize,
        concat!("Size of: ", stringify!(_fluid_mod_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_mod_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_fluid_mod_t))
    );
    fn test_field_dest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(dest)
            )
        );
    }
    test_field_dest();
    fn test_field_src1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src1) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(src1)
            )
        );
    }
    test_field_src1();
    fn test_field_flags1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags1) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(flags1)
            )
        );
    }
    test_field_flags1();
    fn test_field_src2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src2) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(src2)
            )
        );
    }
    test_field_src2();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_amount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).amount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(amount)
            )
        );
    }
    test_field_amount();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_mod_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_mod_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub const fluid_mod_flags_FLUID_MOD_POSITIVE: fluid_mod_flags = 0;
pub const fluid_mod_flags_FLUID_MOD_NEGATIVE: fluid_mod_flags = 1;
pub const fluid_mod_flags_FLUID_MOD_UNIPOLAR: fluid_mod_flags = 0;
pub const fluid_mod_flags_FLUID_MOD_BIPOLAR: fluid_mod_flags = 2;
pub const fluid_mod_flags_FLUID_MOD_LINEAR: fluid_mod_flags = 0;
pub const fluid_mod_flags_FLUID_MOD_CONCAVE: fluid_mod_flags = 4;
pub const fluid_mod_flags_FLUID_MOD_CONVEX: fluid_mod_flags = 8;
pub const fluid_mod_flags_FLUID_MOD_SWITCH: fluid_mod_flags = 12;
pub const fluid_mod_flags_FLUID_MOD_GC: fluid_mod_flags = 0;
pub const fluid_mod_flags_FLUID_MOD_CC: fluid_mod_flags = 16;
pub type fluid_mod_flags = ::std::os::raw::c_uint;
pub const fluid_mod_src_FLUID_MOD_NONE: fluid_mod_src = 0;
pub const fluid_mod_src_FLUID_MOD_VELOCITY: fluid_mod_src = 2;
pub const fluid_mod_src_FLUID_MOD_KEY: fluid_mod_src = 3;
pub const fluid_mod_src_FLUID_MOD_KEYPRESSURE: fluid_mod_src = 10;
pub const fluid_mod_src_FLUID_MOD_CHANNELPRESSURE: fluid_mod_src = 13;
pub const fluid_mod_src_FLUID_MOD_PITCHWHEEL: fluid_mod_src = 14;
pub const fluid_mod_src_FLUID_MOD_PITCHWHEELSENS: fluid_mod_src = 16;
pub type fluid_mod_src = ::std::os::raw::c_uint;
extern "C" {
    pub fn fluid_mod_new() -> *mut fluid_mod_t;
}
extern "C" {
    pub fn fluid_mod_delete(mod_: *mut fluid_mod_t);
}
extern "C" {
    pub fn fluid_mod_set_source1(
        mod_: *mut fluid_mod_t,
        src: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fluid_mod_set_source2(
        mod_: *mut fluid_mod_t,
        src: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fluid_mod_set_dest(mod_: *mut fluid_mod_t, dst: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fluid_mod_set_amount(mod_: *mut fluid_mod_t, amount: f64);
}
extern "C" {
    pub fn fluid_mod_get_source1(mod_: *mut fluid_mod_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_mod_get_flags1(mod_: *mut fluid_mod_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_mod_get_source2(mod_: *mut fluid_mod_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_mod_get_flags2(mod_: *mut fluid_mod_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_mod_get_dest(mod_: *mut fluid_mod_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_mod_get_amount(mod_: *mut fluid_mod_t) -> f64;
}
extern "C" {
    pub fn fluid_mod_test_identity(
        mod1: *mut fluid_mod_t,
        mod2: *mut fluid_mod_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Sample start address offset (0-32767)"]
pub const fluid_gen_type_GEN_STARTADDROFS: fluid_gen_type = 0;
#[doc = "< Sample end address offset (-32767-0)"]
pub const fluid_gen_type_GEN_ENDADDROFS: fluid_gen_type = 1;
#[doc = "< Sample loop start address offset (-32767-32767)"]
pub const fluid_gen_type_GEN_STARTLOOPADDROFS: fluid_gen_type = 2;
#[doc = "< Sample loop end address offset (-32767-32767)"]
pub const fluid_gen_type_GEN_ENDLOOPADDROFS: fluid_gen_type = 3;
#[doc = "< Sample start address coarse offset (X 32768)"]
pub const fluid_gen_type_GEN_STARTADDRCOARSEOFS: fluid_gen_type = 4;
#[doc = "< Modulation LFO to pitch"]
pub const fluid_gen_type_GEN_MODLFOTOPITCH: fluid_gen_type = 5;
#[doc = "< Vibrato LFO to pitch"]
pub const fluid_gen_type_GEN_VIBLFOTOPITCH: fluid_gen_type = 6;
#[doc = "< Modulation envelope to pitch"]
pub const fluid_gen_type_GEN_MODENVTOPITCH: fluid_gen_type = 7;
#[doc = "< Filter cutoff"]
pub const fluid_gen_type_GEN_FILTERFC: fluid_gen_type = 8;
#[doc = "< Filter Q"]
pub const fluid_gen_type_GEN_FILTERQ: fluid_gen_type = 9;
#[doc = "< Modulation LFO to filter cutoff"]
pub const fluid_gen_type_GEN_MODLFOTOFILTERFC: fluid_gen_type = 10;
#[doc = "< Modulation envelope to filter cutoff"]
pub const fluid_gen_type_GEN_MODENVTOFILTERFC: fluid_gen_type = 11;
#[doc = "< Sample end address coarse offset (X 32768)"]
pub const fluid_gen_type_GEN_ENDADDRCOARSEOFS: fluid_gen_type = 12;
#[doc = "< Modulation LFO to volume"]
pub const fluid_gen_type_GEN_MODLFOTOVOL: fluid_gen_type = 13;
#[doc = "< Unused"]
pub const fluid_gen_type_GEN_UNUSED1: fluid_gen_type = 14;
#[doc = "< Chorus send amount"]
pub const fluid_gen_type_GEN_CHORUSSEND: fluid_gen_type = 15;
#[doc = "< Reverb send amount"]
pub const fluid_gen_type_GEN_REVERBSEND: fluid_gen_type = 16;
#[doc = "< Stereo panning"]
pub const fluid_gen_type_GEN_PAN: fluid_gen_type = 17;
#[doc = "< Unused"]
pub const fluid_gen_type_GEN_UNUSED2: fluid_gen_type = 18;
#[doc = "< Unused"]
pub const fluid_gen_type_GEN_UNUSED3: fluid_gen_type = 19;
#[doc = "< Unused"]
pub const fluid_gen_type_GEN_UNUSED4: fluid_gen_type = 20;
#[doc = "< Modulation LFO delay"]
pub const fluid_gen_type_GEN_MODLFODELAY: fluid_gen_type = 21;
#[doc = "< Modulation LFO frequency"]
pub const fluid_gen_type_GEN_MODLFOFREQ: fluid_gen_type = 22;
#[doc = "< Vibrato LFO delay"]
pub const fluid_gen_type_GEN_VIBLFODELAY: fluid_gen_type = 23;
#[doc = "< Vibrato LFO frequency"]
pub const fluid_gen_type_GEN_VIBLFOFREQ: fluid_gen_type = 24;
#[doc = "< Modulation envelope delay"]
pub const fluid_gen_type_GEN_MODENVDELAY: fluid_gen_type = 25;
#[doc = "< Modulation envelope attack"]
pub const fluid_gen_type_GEN_MODENVATTACK: fluid_gen_type = 26;
#[doc = "< Modulation envelope hold"]
pub const fluid_gen_type_GEN_MODENVHOLD: fluid_gen_type = 27;
#[doc = "< Modulation envelope decay"]
pub const fluid_gen_type_GEN_MODENVDECAY: fluid_gen_type = 28;
#[doc = "< Modulation envelope sustain"]
pub const fluid_gen_type_GEN_MODENVSUSTAIN: fluid_gen_type = 29;
#[doc = "< Modulation envelope release"]
pub const fluid_gen_type_GEN_MODENVRELEASE: fluid_gen_type = 30;
#[doc = "< Key to modulation envelope hold"]
pub const fluid_gen_type_GEN_KEYTOMODENVHOLD: fluid_gen_type = 31;
#[doc = "< Key to modulation envelope decay"]
pub const fluid_gen_type_GEN_KEYTOMODENVDECAY: fluid_gen_type = 32;
#[doc = "< Volume envelope delay"]
pub const fluid_gen_type_GEN_VOLENVDELAY: fluid_gen_type = 33;
#[doc = "< Volume envelope attack"]
pub const fluid_gen_type_GEN_VOLENVATTACK: fluid_gen_type = 34;
#[doc = "< Volume envelope hold"]
pub const fluid_gen_type_GEN_VOLENVHOLD: fluid_gen_type = 35;
#[doc = "< Volume envelope decay"]
pub const fluid_gen_type_GEN_VOLENVDECAY: fluid_gen_type = 36;
#[doc = "< Volume envelope sustain"]
pub const fluid_gen_type_GEN_VOLENVSUSTAIN: fluid_gen_type = 37;
#[doc = "< Volume envelope release"]
pub const fluid_gen_type_GEN_VOLENVRELEASE: fluid_gen_type = 38;
#[doc = "< Key to volume envelope hold"]
pub const fluid_gen_type_GEN_KEYTOVOLENVHOLD: fluid_gen_type = 39;
#[doc = "< Key to volume envelope decay"]
pub const fluid_gen_type_GEN_KEYTOVOLENVDECAY: fluid_gen_type = 40;
#[doc = "< Instrument ID (shouldn't be set by user)"]
pub const fluid_gen_type_GEN_INSTRUMENT: fluid_gen_type = 41;
#[doc = "< Reserved"]
pub const fluid_gen_type_GEN_RESERVED1: fluid_gen_type = 42;
#[doc = "< MIDI note range"]
pub const fluid_gen_type_GEN_KEYRANGE: fluid_gen_type = 43;
#[doc = "< MIDI velocity range"]
pub const fluid_gen_type_GEN_VELRANGE: fluid_gen_type = 44;
#[doc = "< Sample start loop address coarse offset (X 32768)"]
pub const fluid_gen_type_GEN_STARTLOOPADDRCOARSEOFS: fluid_gen_type = 45;
#[doc = "< Fixed MIDI note number"]
pub const fluid_gen_type_GEN_KEYNUM: fluid_gen_type = 46;
#[doc = "< Fixed MIDI velocity value"]
pub const fluid_gen_type_GEN_VELOCITY: fluid_gen_type = 47;
#[doc = "< Initial volume attenuation"]
pub const fluid_gen_type_GEN_ATTENUATION: fluid_gen_type = 48;
#[doc = "< Reserved"]
pub const fluid_gen_type_GEN_RESERVED2: fluid_gen_type = 49;
#[doc = "< Sample end loop address coarse offset (X 32768)"]
pub const fluid_gen_type_GEN_ENDLOOPADDRCOARSEOFS: fluid_gen_type = 50;
#[doc = "< Coarse tuning"]
pub const fluid_gen_type_GEN_COARSETUNE: fluid_gen_type = 51;
#[doc = "< Fine tuning"]
pub const fluid_gen_type_GEN_FINETUNE: fluid_gen_type = 52;
#[doc = "< Sample ID (shouldn't be set by user)"]
pub const fluid_gen_type_GEN_SAMPLEID: fluid_gen_type = 53;
#[doc = "< Sample mode flags"]
pub const fluid_gen_type_GEN_SAMPLEMODE: fluid_gen_type = 54;
#[doc = "< Reserved"]
pub const fluid_gen_type_GEN_RESERVED3: fluid_gen_type = 55;
#[doc = "< Scale tuning"]
pub const fluid_gen_type_GEN_SCALETUNE: fluid_gen_type = 56;
#[doc = "< Exclusive class number"]
pub const fluid_gen_type_GEN_EXCLUSIVECLASS: fluid_gen_type = 57;
#[doc = "< Sample root note override"]
pub const fluid_gen_type_GEN_OVERRIDEROOTKEY: fluid_gen_type = 58;
#[doc = "< Pitch (NOTE: Not a real SoundFont generator)"]
pub const fluid_gen_type_GEN_PITCH: fluid_gen_type = 59;
#[doc = "< Value defines the count of generators (#fluid_gen_type)"]
pub const fluid_gen_type_GEN_LAST: fluid_gen_type = 60;
#[doc = " Generator (effect) numbers (Soundfont 2.01 specifications section 8.1.3)"]
pub type fluid_gen_type = ::std::os::raw::c_uint;
#[doc = " SoundFont generator structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fluid_gen_t {
    #[doc = "< Is the generator set or not (#fluid_gen_flags)"]
    pub flags: ::std::os::raw::c_uchar,
    #[doc = "< The nominal value"]
    pub val: f64,
    #[doc = "< Change by modulators"]
    pub mod_: f64,
    #[doc = "< Change by NRPN messages"]
    pub nrpn: f64,
}
#[test]
fn bindgen_test_layout__fluid_gen_t() {
    assert_eq!(
        ::std::mem::size_of::<_fluid_gen_t>(),
        32usize,
        concat!("Size of: ", stringify!(_fluid_gen_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_fluid_gen_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_fluid_gen_t))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_gen_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_gen_t),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_gen_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_gen_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
    fn test_field_mod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_gen_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mod_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_gen_t),
                "::",
                stringify!(mod_)
            )
        );
    }
    test_field_mod();
    fn test_field_nrpn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_fluid_gen_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nrpn) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_fluid_gen_t),
                "::",
                stringify!(nrpn)
            )
        );
    }
    test_field_nrpn();
}
#[doc = " SoundFont generator structure."]
pub type fluid_gen_t = _fluid_gen_t;
#[doc = "< Generator value is not set"]
pub const fluid_gen_flags_GEN_UNUSED: fluid_gen_flags = 0;
#[doc = "< Generator value is set"]
pub const fluid_gen_flags_GEN_SET: fluid_gen_flags = 1;
#[doc = "< DOCME"]
pub const fluid_gen_flags_GEN_ABS_NRPN: fluid_gen_flags = 2;
#[doc = " Enum value for 'flags' field of #_fluid_gen_t (not really flags)."]
pub type fluid_gen_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn fluid_gen_set_default_values(gen: *mut fluid_gen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update all the synthesis parameters, which depend on generator gen."]
    #[doc = "This is only necessary after changing a generator of an already operating voice."]
    #[doc = "Most applications will not need this function."]
    pub fn fluid_voice_update_param(voice: *mut fluid_voice_t, gen: ::std::os::raw::c_int);
}
pub const fluid_voice_add_mod_FLUID_VOICE_OVERWRITE: fluid_voice_add_mod = 0;
pub const fluid_voice_add_mod_FLUID_VOICE_ADD: fluid_voice_add_mod = 1;
pub const fluid_voice_add_mod_FLUID_VOICE_DEFAULT: fluid_voice_add_mod = 2;
pub type fluid_voice_add_mod = ::std::os::raw::c_uint;
extern "C" {
    pub fn fluid_voice_add_mod(
        voice: *mut fluid_voice_t,
        mod_: *mut fluid_mod_t,
        mode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set the value of a generator"]
    pub fn fluid_voice_gen_set(voice: *mut fluid_voice_t, gen: ::std::os::raw::c_int, val: f32);
}
extern "C" {
    #[doc = " Get the value of a generator"]
    pub fn fluid_voice_gen_get(voice: *mut fluid_voice_t, gen: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = " Modify the value of a generator by val"]
    pub fn fluid_voice_gen_incr(voice: *mut fluid_voice_t, gen: ::std::os::raw::c_int, val: f32);
}
extern "C" {
    #[doc = " Return the unique ID of the noteon-event. A sound font loader"]
    #[doc = "  may store the voice processes it has created for * real-time"]
    #[doc = "  control during the operation of a voice (for example: parameter"]
    #[doc = "  changes in sound font editor). The synth uses a pool of"]
    #[doc = "  voices, which are 'recycled' and never deallocated."]
    #[doc = ""]
    #[doc = " Before modifying an existing voice, check"]
    #[doc = " - that its state is still 'playing'"]
    #[doc = " - that the ID is still the same"]
    #[doc = " Otherwise the voice has finished playing."]
    pub fn fluid_voice_get_id(voice: *mut fluid_voice_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fluid_voice_is_playing(voice: *mut fluid_voice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If the peak volume during the loop is known, then the voice can"]
    #[doc = " be released earlier during the release phase. Otherwise, the"]
    #[doc = " voice will operate (inaudibly), until the envelope is at the"]
    #[doc = " nominal turnoff point. In many cases the loop volume is many dB"]
    #[doc = " below the maximum volume.  For example, the loop volume for a"]
    #[doc = " typical acoustic piano is 20 dB below max.  Taking that into"]
    #[doc = " account in the turn-off algorithm we can save 20 dB / 100 dB =>"]
    #[doc = " 1/5 of the total release time."]
    #[doc = " So it's a good idea to call fluid_voice_optimize_sample"]
    #[doc = " on each sample once."]
    pub fn fluid_voice_optimize_sample(s: *mut fluid_sample_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fluid_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        micro: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fluid_version_str() -> *mut ::std::os::raw::c_char;
}
